!---------------------------------- LICENCE BEGIN -------------------------------
! GEM - Library of kernel routines for the GEM numerical atmospheric model
! Copyright (C) 1990-2010 - Division de Recherche en Prevision Numerique
!                       Environnement Canada
! This library is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published by
! the Free Software Foundation, version 2.1 of the License. This library is
! distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
! without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
! PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
! You should have received a copy of the GNU Lesser General Public License
! along with this library; if not, write to the Free Software Foundation, Inc.,
! 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
!---------------------------------- LICENCE END ---------------------------------

!** matvec3D Matrix-vector product subroutines (P & H coordinates)
!
      subroutine matvec3D(F_vector, F_prod, minx,maxx,miny,maxy)
      use dyn_fisl_options
      use geomh
      use gem_options
      use HORgrid_options
      use dynkernel_options
      use lam_options
      use glb_ld
      use ldnh
      use sol
      use metric
      use, intrinsic :: iso_fortran_env
      implicit none
#include <arch_specific.hf>
      integer, intent(in) ::  minx,maxx,miny,maxy
      real(kind=REAL64), dimension(minx:maxx,miny:maxy,l_nk), intent(in) :: F_vector
      real(kind=REAL64), dimension(1-ovlpx:l_ni+ovlpx,1-ovlpy:l_nj+ovlpy,l_nk), intent(out) :: F_prod

! Author:

      integer, parameter :: IDX_POINT=1, IDX_WEST=2, IDX_EAST=3, IDX_NORTH=4, IDX_SOUTH=5, IDX_TOP=6, IDX_BOTTOM=7
      real linfini
      integer :: i, j, k, k0, k0t, km, kp
      real(kind=REAL64), dimension(l_minx:l_maxx, l_miny:l_maxy,0:l_nk+1) :: vector
      real(kind=REAL64), dimension(ldnh_minx:ldnh_maxx, ldnh_miny:ldnh_maxy,l_nk) :: work_8
      real, dimension(l_minx:l_maxx, l_miny:l_maxy,l_nk+1) :: fdg2

! MATVEC in case H coordinates and FISLH_metric_L=.false. , and P coordinates

      if( .not. FISLH_LHS_metric_L) then
!$omp single
         vector = 0.0d0
         do k=1,l_nk
            do j=1+sol_pil_s, l_nj-sol_pil_n
               do i=1+sol_pil_w, l_ni-sol_pil_e
                  vector( i, j,k) = F_vector(i, j,k)
               end do
            end do
         end do

         call rpn_comm_xch_halo_8 (vector(:,:,0:l_nk+1),l_minx, l_maxx, l_miny, l_maxy, l_ni, l_nj, l_nk+2, &
                           G_halox, G_haloy, G_periodx, G_periody, l_ni,0 )


         do k=1,l_nk
            do j=1+sol_pil_s, l_nj-sol_pil_n
               do i=1+sol_pil_w, l_ni-sol_pil_e
                  F_prod(i,j,k) = Sol_stencilp_8(i, j, IDX_POINT, k) * vector(i  , j ,k ) &
                                + Sol_stencilp_8(i, j, IDX_WEST,  k) * vector(i-1, j ,k ) &
                                + Sol_stencilp_8(i, j, IDX_EAST,  k) * vector(i+1, j ,k ) &
                                + Sol_stencilp_8(i, j, IDX_NORTH, k) * vector(i  , j+1,k) &
                                + Sol_stencilp_8(i, j, IDX_SOUTH, k) * vector(i  , j-1,k) &
                                + Sol_stencilp_8(i, j, IDX_TOP, k)   * vector(i  ,j  ,k-1)&
                                + Sol_stencilp_8(i, j, IDX_BOTTOM, k)* vector(i  ,j  ,k+1)
               end do
            end do
         end do

         if (Grd_yinyang_L) then
            work_8 =0.0
            call yyg_rhs_xchng (work_8, vector(l_minx,l_miny,1)        ,&
                                ldnh_minx,ldnh_maxx,ldnh_miny,ldnh_maxy,&
                                l_minx,l_maxx,l_miny,l_maxy,l_nk,-1,linfini)
            do k=1,l_nk
               do j=1+sol_pil_s, l_nj-sol_pil_n
                  do i=1+sol_pil_w, l_ni-sol_pil_e
                     F_prod(i,j,k)= F_prod(i,j,k)+work_8(i,j,k)/ geomh_area_8(i,j)
                  end do
               end do
            end do
         end if
!$omp end single

! MATVEC in case of H coordinate and FISLH_metric_L=.true.
      else

         k0=1+Lam_gbpil_T
         k0t=k0
         if (Schm_opentop_L) k0t=k0-1

         fdg2(:,:,:) = 0.

         do k = k0, l_nk
            do j=1+sol_pil_s, l_nj-sol_pil_n
               do i=1+sol_pil_w, l_ni-sol_pil_e
                  fdg2(i,j,k)=F_vector(i,j,k)
               end do
            end do
         end do

         do j=1+sol_pil_s, l_nj-sol_pil_n
            do i=1+sol_pil_w, l_ni-sol_pil_e
                  fdg2(i,j,l_nk+1) =GVM%mc_alfas_H_8(i,j) * F_vector(i,j,l_nk)   &
                                   -GVM%mc_betas_H_8(i,j) * F_vector(i,j,l_nk-1)
            end do
         end do
         if (Schm_opentop_L) then
            do j=1+sol_pil_s, l_nj-sol_pil_n
               do i=1+sol_pil_w, l_ni-sol_pil_e
                  fdg2(i,j,k0t) = GVM%mc_alfat_8(i,j)* F_vector(i,j,k0)
               end do
            end do
         endif

         if ( Grd_yinyang_L) then
            call yyg_xchng (fdg2, l_minx,l_maxx,l_miny,l_maxy, &
                                  l_ni,l_nj, l_nk+1, .false., 'CUBIC', .true.)
         else
            call rpn_comm_xch_halo(fdg2 ,l_minx,l_maxx,l_miny,l_maxy,l_ni,l_nj,l_nk+1, &
                                1,1,G_periodx,G_periody,l_ni,0 )
         endif

         do k=k0,l_nk
            do j=1+sol_pil_s, l_nj-sol_pil_n
               km=max(k-1,1)
               kp=k+1
                  do i=1+sol_pil_w, l_ni-sol_pil_e
                     F_prod(i,j,k)= Sol_stencilh_8 (i,j,k, 1)*fdg2(i,  j,  k  ) &
                                 +  Sol_stencilh_8 (i,j,k, 2)*fdg2(i-1,j,  k  ) &
                                 +  Sol_stencilh_8 (i,j,k, 3)*fdg2(i+1,j,  k  ) &
                                 +  Sol_stencilh_8 (i,j,k, 4)*fdg2(i,  j,  km) &
                                 +  Sol_stencilh_8 (i,j,k, 5)*fdg2(i,  j,  kp) &
                                 +  Sol_stencilh_8 (i,j,k, 6)*fdg2(i-1,j,  km) &
                                 +  Sol_stencilh_8 (i,j,k, 7)*fdg2(i-1,j,  kp) &
                                 +  Sol_stencilh_8 (i,j,k, 8)*fdg2(i+1,j,  km) &
                                 +  Sol_stencilh_8 (i,j,k, 9)*fdg2(i+1,j,  kp) &
                                 +  Sol_stencilh_8 (i,j,k,10)*fdg2(i,  j-1,k  ) &
                                 +  Sol_stencilh_8 (i,j,k,11)*fdg2(i,  j+1,k  ) &
                                 +  Sol_stencilh_8 (i,j,k,12)*fdg2(i,  j-1,km) &
                                 +  Sol_stencilh_8 (i,j,k,13)*fdg2(i,  j-1,kp) &
                                 +  Sol_stencilh_8 (i,j,k,14)*fdg2(i,  j+1,km) &
                                 +  Sol_stencilh_8 (i,j,k,15)*fdg2(i,  j+1,kp)
                     end do
                  end do
               end do

      endif

   end subroutine matvec3D

